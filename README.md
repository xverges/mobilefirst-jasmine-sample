#Unit test your JavaScript code in IBM MobileFirst hybrid applications

This project builds on the [developerWorks article *Unit test your 
JavaScript code in IBM Worklight hybrid applications*](https://www.ibm.com/developerworks/community/blogs/worklight/entry/unit_test_your_javascript_code_in_ibm_worklight_hybrid_applications) 
by [Mike Rheinheimer](https://twitter.com/mikerott)
and takes different choices on tools. We move from Java-based tools
dealing with JavaScript, to node.js-based tool, a landscape that is
moving much faster and that makes plumbing simpler.

## node.js and npm

The last step in this README deals with having Maven download
in the project area all the proper versions of the tools used
to test the JavaScript code in the project. However, it is
more comfortable to use the tools as they are installed usually.
Thus, I'm assuming that [node.js is installed](http://nodejs.org/download/)
and `node` and `npm` are in the path.

We'll take advantage of npm to download all the dependencies. To
do so, we will need a `package.json` file in the root of our project.
If you run `npm init` you'll be asked some questions and have the
file created for you.

## Grunt

[Grunt](http://gruntjs.com/getting-started) calls itself *the JavaScript 
Task Runner* and belongs to the same family of tools that make, Ant...

Again, I am assuming that it is in the path because you've run `npm -g grunt-cli` 
so that `grunt` is in your path, I also assume that you are familiar with its configuration
file, `Gruntfile.js`.

Once we are done, running `grunt --help` will show 

    Available tasks
        jshint  Validate files with JSHint. *
       jasmine  Run jasmine specs headlessly through PhantomJS. *
          test  Alias for "jshint", "jasmine" tasks.

and `grunt test` will do the tasks that we are interested in.

We could also be running the MobileFirst from Grunt, as seen in 
this video: [Integrating IBM MobileFirst CLI with 
Grunt](https://www.youtube.com/watch?v=tFvogRMC4ss)

### Keeping Eclipse happy

Once we start running `npm install...` we will have a `node_modules`
folder in the project's root. We don't want Eclipse taking care of
it, so in the Project Properties we can edit the Resource Filters:

![Resource Filters](https://dl.dropboxusercontent.com/u/1724711/resource_filters.PNG)


## JSHint
[JSHint](http://jshint.com/about/) is a *community-driven tool 
to detect errors and potential problems in JavaScript code and to 
enforce your team's coding conventions*. In the original article,
[JSHint options](http://jshint.com/docs/options/) were defined 
in the project's `pom.xml`. We will be using `.jshintrc` files in 
different directories. This has two advantages:

* we can have different options for client code, adapters and tests. 
* our options are understood by most JSHint-based tools, including 
  its [node.js-based command line tool](https://www.npmjs.com/package/jshint)
  or VIM plugins. Unfortunately, [jshint-eclipse](http://github.eclipsesource.com/jshint-eclipse/)
  still does [not support dealing with multiple 
  .jshintrc files](https://github.com/eclipsesource/jshint-eclipse/issues/105)

We need to install its [grunt plugin](https://github.com/gruntjs/grunt-contrib-jshint), 
with `npm install grunt-contrib-jshint --save-dev`,
and make its tasks available in the Gruntfile by adding to it

    grunt.loadNpmTasks('grunt-contrib-jshint');

This is the relevant section in the Gruntfile:

    jshint: {
        options: {
            jshintrc: true
        },
        js: {
            src: ['Gruntfile.js',
                  'adapters/**/*.js',
                  'apps/*/common/js/**/*.js',
                  'apps/*/spec/*.js']
        },
        html: {
            src: ['apps/*/common/**/*.html'],
            options: {
                extract: 'always'
            }
        }
    }

Checking the JavaScript in HTML files has forced me to hide from JSHint
a line generated by default by MobileFirst. Haven't got a clue about
the reason.

    <script>
        /* jshint ignore:start */
        /* Causes a puzzling 'Invalid array length' */
        window.$ = window.jQuery = WLJQ;
        /* jshint ignore:end */
    </script>

## QUnit

The original article uses [QUnit](http://qunitjs.com/) as its test framework.
Tests are executed either by hand refreshing the browser or driven by Maven and
executed on [PhantomJS](http://phantomjs.org/headless-testing.html).

A [grunt plugin](https://github.com/gruntjs/grunt-contrib-qunit) makes the
task of having command line driven tests executed in PhantomJS simple.
However, I have used Jasmine instead of QUnit for my testing.

## Jasmine

[Jasmine](http://jasmine.github.io/2.0/introduction.html) is popular BDD 
(behaviuor-driven development) framework, that makes easy write expressive tests.
Like QUnit, there is also a grunt plugin that makes simple the task of executing the
tests on [PhantomJS](http://phantomjs.org/headless-testing.html).

Like with any grunt plugin, we need to install it, 

    npm install grunt-contrib-jasmine --save-dev

and then make its tasks available to the Gruntfile

    grunt.loadNpmTasks('grunt-contrib-jasmine');

In Jasmine one usually talks about suites, specs and spec files. Here is
a very simple spec file for our project, that we have in `apps/appName/specs/mainSpec.js`:

    describe('Main', function() {
        it('should define a MyWLApp global object', function() {
            expect(MyWLApp).toBeDefined();
        });
    });


For every app in our project, we will do something similar to this, that
loads all the client files and runs the specs in the `spec` folder:


    jasmine: {
        firstApp: {
            src: firstAppPath + '/common/js/**/*.js',
            options: {
                    specs: firstAppPath + '/spec/*Spec.js'
                }
            }
        },
        ...
    }

### Testing adapters

Although adapters really run in Rhino, we can also take advantage of our
Jasmine-PhantomJS infrastructure to test them. However, we have to keep
in mind that, unlike client code, different scripts don't share context,
so we cannot use wildcards: we need to run one of the at a time. To prevent
forgetting about adding them to the Gruntfile, it would be good to add some
logic to process wildcards and to the jasmine config the required executions.
By now, the manual process, with every adapter listed in the Gruntfile:

    userDataAdapter: {
        src: 'adapters/UserDataAdapter/UserDataAdapter-impl.js',
        options: {
            specs: 'test/js/spec/userDataAdapterSpec.js'
        }
    }


### Mocking WL.\* methods

Our code is probably using MobileFirst features using the `WL.*` namespaces.
In order to take advantage of Jasmine mocking features, we need to have some
methods defined. I've opted for creating the `test\js\lib\wl.client-side.dummy.js`
and `test\js\lib\wl.server-side.dummy.js` files, and adding them as a vendor files 
in the Gruntfile definition for the Jasmine tasks. But I feel uncomfortable: I dislike
the idea of creating by hand the dummy files and to have to copy them from project
to project.

To have the dummy files included in the test execution, I have added them in
the `vendor` section of the jasmine configuration:


    jasmine: {
        ...
            options: {
                vendor: ['test/js/lib/wl.client-side.dummy.js'],
                specs: ...
            }
        }

### And if the code relies on jQuery?

Our code or our tests may need to have jQuery available in our Jasmine run. We can build
it or use the one that MobileFirst uses when it creates an environment. In
this project I've built it, using `npm install grunt-jquery-builder --save-dev`.
I have configured the build in the Gruntfile with

    jquery: {
        jasmine_jquery: {
            output: "node_modules/grunt-jquery-builder/built",
            versions: ["1.9.1"], 
            options: {
                prefix: "jquery-",
                minify: false
            }
        }
    }

I have also made `npm install` generate the jQuery library by changing the `scripts` 
section in `package.json`.

    "scripts": {
        "test": "grunt test",
        "prepublish": "grunt jquery"
    }

The built file goes also in the `vendor` property of the jasmine configuration. 

### Using Jasmine to test the DOM

In order to test the effects of our scripts in the DOM, we can use 
[jasmine-jquery](https://github.com/velesin/jasmine-jquery),
self described as *jQuery matchers and fixture loader for Jasmine framework*.

To install the package itself, `npm install jasmine-jquery --save-dev` is enough.

The fixture loader allows to load snippets of HTML code and have the code manipulate
them during the tests.


    it('should load fixtures and assert their contents', function() {
        jasmine.getFixtures().load('sample.html');
        expect($('#sample')[0]).toBeInDOM();
        expect($('#sample')[0]).toContainText('ample text');
    });

## Wrapping everything with Maven

The original article ends up wrapping everything in maven.
Since Grunt and its plugins have taken care of all the plumbing,
we'll take advantage of a recent maven plugin that can drive grunt:
[frontend-maven-plugin](https://github.com/eirslett/frontend-maven-plugin).
The plugin takes care of downloading node.js, so that automated
builds always use the same version, and of driving grunt.

The `pom.xml` file in this project is configured to install 
node during the `initialize` phase, and to call `grunt test`
during the `test` phase (`mvn test`, or, to just call grunt,
`mvn frontend:grunt`). 

Calling `grunt test` from maven won't use the globally installed
`grunt-cli` package: it is a self-contained execution. Thus, it
won't work unless we install the package in our project. Again,
`npm install grunt-cli --save-dev`. 

This plugin installs node in the project's root ([although this
is likely to change](https://github.com/eirslett/frontend-maven-plugin/issues/18)).
Again, if using Eclipse, we will want it to ignore the folder, so
we will need to change the resource filters (see above).




